var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { parse } from '../parser';
import { createFlowchart } from '../flowchart';
import { mergeDefaultConfig } from '../config';
var DEBUG = false;
var Renderer = /** @class */ (function () {
    function Renderer(_a) {
        var _this = this;
        var src = _a.src, config = _a.config, document = _a.document;
        this.el = function (tagName, attrs) {
            var children = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                children[_i - 2] = arguments[_i];
            }
            var e = _this._document.createElementNS('http://www.w3.org/2000/svg', tagName);
            Object.entries(attrs || {})
                .forEach(function (_a) {
                var k = _a[0], v = _a[1];
                return e.setAttribute(k === 'className' ? 'class' : k, v.toString());
            });
            (children || []).forEach(function (child) { return e.append(child); });
            return e;
        };
        this.createTextSVGElement = function (text, attrs) {
            var el = _this.el;
            var textSVG = el('text', attrs || {});
            text.split(/\\n/).forEach(function (line, idx) {
                textSVG.append(el('tspan', { x: attrs.x, dy: (idx === 0 ? 0 : 1) + "em" }, line));
            });
            return textSVG;
        };
        // this is not good...
        this.measureText = function (text, attrs) {
            if (attrs === void 0) { attrs = {}; }
            var _a = _this, dummySVG = _a.dummySVG, createTextSVGElement = _a.createTextSVGElement;
            var _attrs = __assign(__assign({}, attrs), { x: (attrs.x || 0) });
            _this._document.body.append(dummySVG);
            var textSVG = createTextSVGElement(text, _attrs);
            dummySVG.append(textSVG);
            var _b = textSVG.getBoundingClientRect(), width = _b.width, height = _b.height;
            dummySVG.removeChild(textSVG);
            _this._document.body.removeChild(dummySVG);
            return { w: width, h: height };
        };
        this.renderShape = function (_a) {
            var layers = _a.layers, shape = _a.shape, _b = _a.offsetX, offsetX = _b === void 0 ? 0 : _b, _c = _a.offsetY, offsetY = _c === void 0 ? 0 : _c;
            var x = offsetX + shape.x;
            var y = offsetY + shape.y;
            switch (shape.type) {
                case 'group':
                    shape.children.forEach(function (child) { return _this.renderShape({ layers: layers, shape: child, offsetX: x, offsetY: y }); });
                    break;
                case 'text':
                    layers.textLayer.append(_this.renderText({ x: x, y: y, shape: shape }));
                    break;
                case 'path':
                    layers.pathLayer.append(_this.renderPath({ x: x, y: y, shape: shape }));
                    break;
                case 'rect':
                    layers.nodeLayer.append(_this.renderRect({ x: x, y: y, shape: shape }));
                    break;
                case 'frame':
                    layers.frameLayer.append(_this.renderFrame({ x: x, y: y, shape: shape }));
                    break;
                case 'diamond':
                    layers.nodeLayer.append(_this.renderDiamond({ x: x, y: y, shape: shape }));
                    break;
                case 'point':
                    break;
                default:
                    var _ = shape;
                    throw "shape " + _ + " is invalid";
            }
        };
        this.renderText = function (_a) {
            var x = _a.x, y = _a.y, shape = _a.shape;
            var config = _this.config;
            return _this.createTextSVGElement(shape.content, __assign({ x: x, y: y + (shape.isLabel ? _this.labelHeight : _this.textHeight) / 2, 'dominant-baseline': 'central' }, (shape.isLabel ? config.label.attrs : config.text.attrs)));
        };
        this.renderRect = function (_a) {
            var x = _a.x, y = _a.y, shape = _a.shape;
            var config = _this.config;
            var w = shape.w, h = shape.h;
            return _this.el('rect', __assign({ x: x, y: y, width: w, height: h }, config.rect.attrs));
        };
        this.renderFrame = function (_a) {
            var x = _a.x, y = _a.y, shape = _a.shape;
            var config = _this.config;
            var w = shape.w, h = shape.h;
            return _this.el('rect', __assign({ x: x, y: y, width: w, height: h }, config.frame.attrs));
        };
        this.renderDiamond = function (_a) {
            var x = _a.x, y = _a.y, shape = _a.shape;
            var config = _this.config;
            var w = shape.w, h = shape.h;
            return _this.el('polygon', __assign({ points: x + w / 2 + "," + y + ", " + (x + w) + "," + (y + h / 2) + " " + (x + w / 2) + "," + (y + h) + " " + x + "," + (y + h / 2) }, config.diamond.attrs));
        };
        this.renderPath = function (_a) {
            var x = _a.x, y = _a.y, shape = _a.shape;
            var config = _this.config;
            var m = "M " + x + " " + y;
            var l = shape.cmds.map(function (cmd) { return cmd.join(' '); }).join(' ');
            //     arrow = 'marker-end="url(#arrow-head)"' if self.is_arrow else ''
            return _this.el('path', __assign(__assign({ d: m + " " + l }, (shape.isArrow ?
                { 'marker-end': 'url(#arrow-head)' } : {})), config.path.attrs));
        };
        this.render = function () {
            var _a = _this, src = _a.src, config = _a.config, el = _a.el, measureText = _a.measureText, renderShape = _a.renderShape;
            var svg = _this.svg;
            var arrowHeadDef = el('defs', null, el('marker', {
                id: 'arrow-head',
                markerUnits: 'userSpaceOnUse',
                markerWidth: "" + config.arrowHead.size,
                markerHeight: "" + config.arrowHead.size * 2,
                viewBox: '0 0 10 10',
                refX: '10',
                refY: '5',
                orient: 'auto-start-reverse',
            }, el('polygon', __assign({ points: '0,0 0,10 10,5', 'class': 'arrow-head' }, config.arrowHead.attrs))));
            svg.append(arrowHeadDef);
            var backgroundLayer = el('g');
            var frameLayer = el('g');
            var pathLayer = el('g');
            var nodeLayer = el('g');
            var textLayer = el('g');
            var flowchart = createFlowchart({
                node: parse(src, config),
                config: config,
                measureText: measureText,
            });
            renderShape({
                layers: {
                    frameLayer: frameLayer,
                    pathLayer: pathLayer,
                    nodeLayer: nodeLayer,
                    textLayer: textLayer,
                },
                shape: flowchart.shapes,
            });
            svg.append(backgroundLayer);
            svg.append(frameLayer);
            svg.append(pathLayer);
            svg.append(nodeLayer);
            svg.append(textLayer);
            // (x, y) have been moved to (0, 0) in createFlowchart().
            var svgX = 0;
            var svgY = 0;
            var svgWidth = flowchart.shapes.w + config.flowchart.marginX * 2;
            var svgHeight = flowchart.shapes.h + config.flowchart.marginY * 2;
            svg.setAttribute('width', String(svgWidth));
            svg.setAttribute('height', String(svgHeight));
            svg.setAttribute('viewBox', svgX + " " + svgY + " " + svgWidth + " " + svgHeight);
            var backgroundColor = config.flowchart.backgroundColor;
            if (!['', 'none', 'transparent'].includes(backgroundColor)) {
                backgroundLayer.append(el('rect', { x: 0, y: 0, width: svgWidth, height: svgHeight, fill: backgroundColor }));
            }
            return svg;
        };
        this._document = document;
        this.src = src;
        this.config = config = mergeDefaultConfig(config);
        this.dummySVG = this.el('svg');
        this.svg = this.el('svg', {
            version: '1.1',
            xmlns: 'http://www.w3.org/2000/svg',
        });
        this.labelHeight = this.measureText('A', config.label.attrs).h;
        this.textHeight = this.measureText('A', config.text.attrs).h;
    }
    return Renderer;
}());
var render = function (param) {
    if (DEBUG) {
        var s = performance.now();
        var ret = new Renderer(param).render();
        var e = performance.now();
        console.log("rendering: " + (e - s) + " ms");
        return ret;
    }
    else {
        return new Renderer(param).render();
    }
};
export { render, Renderer, };
//# sourceMappingURL=svg.js.map