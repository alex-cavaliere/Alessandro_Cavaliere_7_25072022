var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import { Group, Point, Path, Text, Rect, Frame, Diamond, } from './shape';
import { RangeAllocator, createRangeList } from './range-allocator';
var DEBUG = false;
;
;
var jumpDir = {
    // {{{
    'while': {
        'break': 'E',
        'continue': 'W',
    },
    'doWhile': {
        'break': 'E',
        'continue': 'E',
    },
    'for': {
        'break': 'E',
        'continue': 'W',
    },
};
var LoopStackInfo = /** @class */ (function () {
    function LoopStackInfo(type) {
        if (type === void 0) { type = 'none'; }
        this.type = type;
        this.breaks = [];
        this.continues = [];
    }
    return LoopStackInfo;
}());
var Flowchart = /** @class */ (function () {
    function Flowchart(_a) {
        var _this = this;
        var shapes = _a.shapes, measureText = _a.measureText, config = _a.config, loop = _a.loop, AllocW = _a.AllocW, AllocE = _a.AllocE, x = _a.x, y = _a.y, yesTextSize = _a.yesTextSize, noTextSize = _a.noTextSize;
        this.shiftX = function (x) {
            var _a = _this, shapes = _a.shapes, loop = _a.loop;
            shapes.trans(x, 0);
            _this.x += x;
            var breaks = loop.breaks, continues = loop.continues;
            breaks.forEach(function (point) { return point.trans(x, 0); });
            continues.forEach(function (point) { return point.trans(x, 0); });
        };
        this.step = function (distance, isArrow) {
            if (distance === void 0) { distance = _this.dy; }
            if (isArrow === void 0) { isArrow = false; }
            _this.shapes.add(Path.vline({ x: 0, y: _this.y, step: distance, isArrow: isArrow }));
            _this.move(distance);
        };
        this.stepAbs = function (y, isArrow) {
            if (isArrow === void 0) { isArrow = false; }
            _this.step(y - _this.y, isArrow);
        };
        this.move = function (distance) {
            if (distance === void 0) { distance = _this.dy; }
            // almost same to "step" but do not add vline.
            _this.y += distance;
        };
        this.moveAbs = function (y) {
            _this.move(y - _this.y);
        };
        this.rect = function (_a) {
            var x = _a.x, y = _a.y, text = _a.text;
            var _b = _this.measureText(text, _this.config.text.attrs), tw = _b.w, th = _b.h;
            var _c = _this.config.rect, padX = _c.padX, padY = _c.padY;
            var w = tw + padX * 2;
            var h = th + padY * 2;
            return _this.wrapText({
                cls: Rect,
                text: text,
                x: x, y: y, w: w, h: h, tw: tw, th: th,
            });
        };
        this.diamond = function (_a) {
            var x = _a.x, y = _a.y, text = _a.text;
            var _b = _this.measureText(text, _this.config.text.attrs), tw = _b.w, th = _b.h;
            var ratio = _this.config.diamond.aspectRatio;
            var w = tw + th / ratio;
            var h = th + tw * ratio;
            return _this.wrapText({
                cls: Diamond,
                text: text,
                x: x, y: y, w: w, h: h, tw: tw, th: th,
            });
        };
        this.wrapText = function (_a) {
            var cls = _a.cls, text = _a.text, x = _a.x, y = _a.y, w = _a.w, h = _a.h, tw = _a.tw, th = _a.th;
            var textShape = _this.text({ text: text, x: -tw / 2, y: h / 2 - th / 2, w: tw, h: th, isLabel: false });
            var wrapShape = new cls({ x: -w / 2, w: w, h: h });
            return new Group({ x: x, y: y, children: [textShape, wrapShape] });
        };
        this.text = function (_a) {
            var x = _a.x, y = _a.y, w = _a.w, h = _a.h, text = _a.text, isLabel = _a.isLabel;
            return new Text({
                content: text,
                x: x, y: y,
                w: w, h: h,
                isLabel: isLabel,
            });
        };
        this.textWithAutoSize = function (_a) {
            var x = _a.x, y = _a.y, text = _a.text, isLabel = _a.isLabel;
            return Text.byMeas({ x: x, y: y, text: text, attrs: _this.config.text.attrs, meas: _this.measureText, isLabel: isLabel });
        };
        this.stepText = function (content) {
            var _a = _this, dy = _a.dy, hlineMargin = _a.hlineMargin;
            var rect = _this.rect({ x: 0, y: 0, text: content });
            // find the space to put vline and rectangle.
            var pos = _this.AllocE.findSpace(_this.y + dy - hlineMargin, rect.h + hlineMargin);
            // keep allocated y-coordinate range.
            _this.AllocW.merge(pos, rect.h + hlineMargin);
            _this.stepAbs(pos + hlineMargin, true);
            rect.trans(0, _this.y);
            _this.shapes.add(rect);
            _this.move(rect.h);
        };
        this.stepCond = function (_a) {
            var content = _a.content, yesDir = _a.yesDir, noDir = _a.noDir, jumpW = _a.jumpW, jumpE = _a.jumpE, _b = _a.stepY, stepY = _b === void 0 ? _this.dy : _b;
            var _c = _this, AllocW = _c.AllocW, AllocE = _c.AllocE, shapes = _c.shapes, diamond = _c.diamond, text = _c.text, stepAbs = _c.stepAbs, move = _c.move, hlineMargin = _c.hlineMargin, yesTextSize = _c.yesTextSize, noTextSize = _c.noTextSize;
            var _d = _this.config.label, yesText = _d.yesText, noText = _d.noText;
            var _e = _this.config.label, labelMarginX = _e.marginX, labelMarginY = _e.marginY;
            var cond = diamond({ x: 0, y: 0, text: content });
            // find the space to put hline and diamond.
            var pos;
            if (jumpW) {
                var currentPos = _this.y + stepY - hlineMargin;
                while (true) {
                    // find the space to put diamond.
                    var posE = AllocE.findSpace(currentPos, cond.h + hlineMargin);
                    // find the space to put hline.
                    var posW = AllocW.findSpace(posE + cond.h / 2, hlineMargin);
                    if (posW === posE + cond.h / 2) {
                        pos = posE;
                        break;
                    }
                    else {
                        currentPos = posW - cond.h / 2;
                    }
                }
            }
            else {
                pos = AllocE.findSpace(_this.y + stepY - hlineMargin, cond.h + hlineMargin);
            }
            AllocW.merge(pos, cond.h + hlineMargin);
            if (jumpE)
                AllocE.merge(pos + cond.h / 2, hlineMargin);
            stepAbs(pos + hlineMargin, true);
            cond.trans(0, _this.y);
            shapes.add(cond);
            move(cond.h);
            var condPos = {
                E: { x: cond.w / 2, y: cond.y + cond.h / 2 },
                W: { x: -cond.w / 2, y: cond.y + cond.h / 2 },
                S: { x: 0, y: cond.y + cond.h },
            };
            var yesTextX = yesDir !== 'W'
                ? condPos[yesDir].x + labelMarginX
                : condPos[yesDir].x - labelMarginX - yesTextSize.w;
            shapes.add(text({
                x: yesTextX,
                y: condPos[yesDir].y + labelMarginY,
                w: yesTextSize.w,
                h: yesTextSize.h,
                text: yesText, isLabel: true,
            }));
            var noTextX = noDir !== 'W'
                ? condPos[noDir].x + labelMarginX
                : condPos[noDir].x - labelMarginX - noTextSize.w;
            shapes.add(text({
                x: noTextX,
                y: condPos[noDir].y + labelMarginY,
                w: noTextSize.w,
                h: noTextSize.h,
                text: noText, isLabel: true,
            }));
            return condPos;
        };
        this.branch = function () {
            if (DEBUG) {
                var msg_1 = '';
                var first = _this.AllocW.ranges()[0];
                var y = Math.round(_this.y);
                if (first) {
                    _this.AllocW.ranges().forEach(function (range) {
                        var start = Math.round(range.start);
                        var end = Math.round(range.end);
                        msg_1 += '\n';
                        msg_1 += "s:" + start + ", e:" + end;
                    });
                }
                else {
                    msg_1 = 'first is undef';
                }
                _this.h(_this.y, "b:" + y + ", " + msg_1);
            }
            return new Flowchart({
                shapes: new Group({ x: _this.x, y: _this.y, children: [] }),
                measureText: _this.measureText,
                config: _this.config,
                loop: new LoopStackInfo(_this.loop.type),
                AllocW: _this.AllocW.clone(),
                AllocE: _this.AllocE.clone(),
                x: _this.x, y: _this.y,
                yesTextSize: _this.yesTextSize,
                noTextSize: _this.noTextSize,
            });
        };
        this.merge = function (flowchart) {
            var _a, _b;
            if (Object.is(_this, flowchart)) {
                throw "cannot merge same flowchart";
            }
            flowchart.shapes.children.forEach(function (child) {
                child.trans(flowchart.shapes.x, 0);
                _this.shapes.add(child);
            });
            (_a = _this.loop.breaks).push.apply(_a, flowchart.loop.breaks);
            (_b = _this.loop.continues).push.apply(_b, flowchart.loop.continues);
            if (flowchart.y > _this.y)
                _this.moveAbs(flowchart.y);
        };
        this.withLoop = function (type, func) {
            var _a = _this, loop = _a.loop, AllocW = _a.AllocW, AllocE = _a.AllocE;
            _this.loop = new LoopStackInfo(type);
            var newAllocW = new RangeAllocator(createRangeList());
            // NOTE: 
            // We have to discard the inner AllocE of loop after loop
            // and consider the outer AllocE of loop.
            // because it is across the block's flowchart.
            //
            // TODO: 
            // the amount of calculation of "cloneDeep()" is O(n) (n is the number of ranges).
            // To reduce the amount, we have to use stack-based allocation and
            // remove the deep copy process.
            var newAllocE = AllocE.cloneDeep();
            // NOTE:
            // We do not have to consider the outer AllocW because
            // laying flowchart out is done from "W" to "E".
            // So, there are no crossing lines from "E".
            var headW = newAllocW.clone();
            var headE = newAllocE.clone();
            _this.AllocW = newAllocW;
            _this.AllocE = newAllocE;
            func();
            var newLoop = _this.loop;
            _this.loop = loop;
            _this.AllocW = AllocW;
            _this.AllocE = AllocE;
            _this.AllocW.mergeAllocator(headW);
            // NOTE: Since laying flowchart out is applied from "W" to "E",
            // we should keep AllocE of inner loop to AllocW.
            _this.AllocW.mergeAllocator(headE);
            return newLoop;
        };
        // to debug
        this.h = function (y, text) {
            if (text === void 0) { text = ''; }
            _this.shapes.add(Path.hline({
                x: 0,
                y: y,
                step: 100,
            }));
            if (text !== '') {
                _this.shapes.add(new Text({
                    content: text,
                    x: 0,
                    y: y,
                    w: 0, h: 0,
                }));
            }
        };
        this.type = 'flowchart';
        this.shapes = shapes;
        this.measureText = measureText;
        this.config = config;
        this.loop = loop;
        this.AllocW = AllocW;
        this.AllocE = AllocE;
        this.alive = true;
        this.dy = config.flowchart.stepY;
        this.dx = config.flowchart.stepX;
        this.hlineMargin = config.flowchart.hlineMargin;
        this.x = x;
        this.y = y;
        this.yesTextSize = yesTextSize;
        this.noTextSize = noTextSize;
    }
    return Flowchart;
}());
var createFlowchart = function (_a) {
    var node = _a.node, config = _a.config, measureText = _a.measureText;
    // {{{
    var flowchart = new Flowchart({
        shapes: new Group({ x: 0, y: 0, children: [] }),
        measureText: measureText,
        config: config,
        loop: new LoopStackInfo(),
        AllocW: new RangeAllocator(createRangeList()),
        AllocE: new RangeAllocator(createRangeList()),
        x: 0, y: config.flowchart.marginY,
        yesTextSize: measureText(config.label.yesText, config.label.attrs),
        noTextSize: measureText(config.label.noText, config.label.attrs),
    });
    createFlowchartSub(node, flowchart);
    flowchart.shiftX(-flowchart.shapes.minX + config.flowchart.marginX);
    return flowchart;
    // }}}
};
var createFlowchartSub = function (node, flowchart, jump) {
    if (jump === void 0) { jump = false; }
    // {{{
    var step = flowchart.step, stepAbs = flowchart.stepAbs, stepText = flowchart.stepText, AllocW = flowchart.AllocW, AllocE = flowchart.AllocE, loop = flowchart.loop, hlineMargin = flowchart.hlineMargin;
    var children = node.children;
    var childNum = children.length;
    var childIdx = 0;
    while (childIdx < childNum && flowchart.alive) {
        var child = children[childIdx];
        switch (child.type) {
            case 'text': {
                stepText(child.content);
                break;
            }
            case 'pass': {
                step();
                break;
            }
            case 'if': {
                var nodes = [];
                if (childIdx < childNum &&
                    children[childIdx].type === 'if') {
                    nodes.push(children[childIdx]);
                    childIdx++;
                }
                while (childIdx < childNum &&
                    children[childIdx].type === 'elif') {
                    nodes.push(children[childIdx]);
                    childIdx++;
                }
                if (childIdx < childNum &&
                    children[childIdx].type === 'else') {
                    nodes.push(children[childIdx]);
                    childIdx++;
                }
                createIfFlowchart(nodes, flowchart);
                continue;
            }
            case 'while': {
                createWhileFlowchart(child, flowchart);
                break;
            }
            case 'do': {
                createDoWhileFlowchart(child, children[childIdx + 1], flowchart);
                childIdx += 2;
                continue;
            }
            case 'break':
            case 'continue': {
                if (loop.type === 'none') {
                    throw 'loop type must not be none here.';
                }
                var direction = jumpDir[loop.type][child.type];
                var pos = void 0;
                if (jump) {
                    pos = flowchart.y - hlineMargin;
                }
                else if (direction === 'W') {
                    pos = flowchart.y;
                    var posPrev = pos - 99999;
                    // find space for both AllocW and AllocE.
                    while (pos !== posPrev) {
                        posPrev = pos;
                        pos = AllocW.findSpace(pos, hlineMargin);
                        pos = AllocE.findSpace(pos, hlineMargin);
                    }
                }
                else {
                    pos = AllocE.findSpace(flowchart.y, hlineMargin);
                }
                AllocW.merge(pos, hlineMargin);
                if (direction === 'E')
                    AllocE.merge(pos, hlineMargin);
                if (!jump)
                    stepAbs(pos + hlineMargin);
                var breaks = loop.breaks, continues = loop.continues;
                (child.type === 'break' ? breaks : continues).push(new Point({ x: 0, y: flowchart.y }));
                flowchart.alive = false;
                break;
            }
            case 'try': {
                var tryNode = child;
                var exceptNodes = [];
                childIdx++;
                while (childIdx < childNum &&
                    children[childIdx].type === 'except') {
                    exceptNodes.push(children[childIdx]);
                    childIdx++;
                }
                createTryExceptFlowchart(tryNode, exceptNodes, flowchart);
                continue;
            }
            case 'switch': {
                var switchNode = child;
                var caseNodes = switchNode.children;
                createSwitchCaseFlowchart(switchNode, caseNodes, flowchart);
                break;
            }
            case 'program':
            case 'none':
            case 'else':
            case 'elif':
            case 'for':
            case 'case':
            case 'except': {
                throw "child type " + child.type + " is not expected. this may be bug...";
                // break;
            }
            default: {
                var _ = child.type;
                throw "child type " + _ + " is invalid.";
            }
        }
        childIdx++;
    }
    // }}}
};
var createIfFlowchart = function (nodes, flowchart, jump) {
    if (jump === void 0) { jump = false; }
    // {{{
    //                 |
    //                 |
    //             _.-' '-._ branchHline
    //            '-._   _.-'----+
    //                '+'        |
    //                 |         |
    // ifShapeGroup +--+--+   +--+--+ elseShapeGroup
    //              |     |   |     |
    //              +--+--+   +--+--+
    //                 |         |
    //                 |         |
    //                 |<--------+
    //                 | mergeHline
    if (nodes.length === 0)
        return;
    if (nodes[0].type === 'else') {
        createFlowchartSub(nodes[0], flowchart, jump);
        return;
    }
    var dx = flowchart.dx, dy = flowchart.dy, hlineMargin = flowchart.hlineMargin;
    var ifFlowchart = flowchart.branch();
    var elseFlowchart = flowchart.branch();
    var loopType = flowchart.loop.type;
    var ifNode = nodes[0];
    var yes = { dir: 'S', jump: false };
    var no = { dir: 'E', jump: false };
    // calculate yes
    if (ifNode.children.length > 0) {
        var type = ifNode.children[0].type;
        if (type === 'break' || type === 'continue') {
            if (loopType === 'none') {
                throw 'loop type must not be none here.';
            }
            yes = { dir: jumpDir[loopType][type], jump: true };
            // if "yes" direction is not "S", default "no" direction is "S".
            no = { dir: 'S', jump: false };
        }
    }
    // if "elif" or "else" exists, calculate no
    if (nodes.length > 1
        && nodes[1].type === 'else'
        && nodes[1].children.length > 0) {
        var type = nodes[1].children[0].type;
        if (type === 'break' || type === 'continue') {
            if (loopType === 'none') {
                throw 'loop type must not be none here.';
            }
            var dir = jumpDir[loopType][type];
            if (dir !== yes.dir)
                no = { dir: dir, jump: true };
        }
    }
    var condPos = flowchart.stepCond({
        content: ifNode.content,
        yesDir: yes.dir,
        noDir: no.dir,
        jumpW: (yes.jump && yes.dir === 'W')
            || (no.jump && no.dir === 'W'),
        jumpE: (yes.jump && yes.dir === 'E')
            || (no.jump && no.dir === 'E'),
        stepY: nodes[0].type === 'if' ? dy : hlineMargin,
    });
    ifFlowchart.moveAbs(condPos[yes.dir].y);
    createFlowchartSub(ifNode, ifFlowchart, yes.jump);
    ifFlowchart.shiftX(condPos[yes.dir].x);
    // create else part flowchart
    elseFlowchart.moveAbs(condPos[no.dir].y);
    createIfFlowchart(nodes.slice(1), elseFlowchart, no.jump);
    if (!no.jump && !yes.jump) {
        var elseFlowchartX = Math.max(condPos.E.x, ifFlowchart.shapes.maxX) + dx - elseFlowchart.shapes.minX;
        elseFlowchart.shiftX(elseFlowchartX);
        ifFlowchart.shapes.add(Path.hline({
            x: condPos.E.x, y: condPos.E.y,
            step: elseFlowchart.shapes.x - condPos.E.x,
        }));
        var mergeY = void 0;
        if (elseFlowchart.alive) {
            var pos = flowchart.AllocE.findSpace(Math.max(ifFlowchart.y, elseFlowchart.y), hlineMargin);
            flowchart.AllocW.merge(pos, hlineMargin);
            mergeY = pos + hlineMargin;
        }
        else {
            mergeY = Math.max(ifFlowchart.y, elseFlowchart.y);
        }
        if (ifFlowchart.alive)
            ifFlowchart.stepAbs(mergeY);
        if (elseFlowchart.alive)
            elseFlowchart.stepAbs(mergeY);
        if (elseFlowchart.alive) {
            ifFlowchart.shapes.add(Path.hline({
                x: elseFlowchart.shapes.x,
                y: mergeY,
                step: -elseFlowchart.shapes.x + ifFlowchart.shapes.x,
                isArrow: ifFlowchart.alive,
            }));
        }
    }
    else {
        elseFlowchart.shiftX(condPos[no.dir].x);
    }
    flowchart.merge(ifFlowchart);
    flowchart.merge(elseFlowchart);
    if (!ifFlowchart.alive && !elseFlowchart.alive)
        flowchart.alive = false;
    // }}}
};
var createWhileFlowchart = function (node, flowchart) {
    // {{{
    //                     |
    //  loop back path     |
    //       +------------>|
    //       |             |
    //       |         _.-' '-._
    //       |        '-._   _.-'-----------+
    //       |            '+'               |
    //       |             |                |
    //       |    block +--+--+             |  loop exit path
    //       |          |     | break       |
    //       |          |     +------------>|
    //       | continue |     |             |
    //       |<---------+     |             |
    //       |          |     |             |
    //       |          +--+--+             |
    //       |             |                |
    //       +-------------+                |
    //                                      |
    //                     +----------------+
    //                     |
    var blockFlowchart = flowchart.branch();
    var moveAbs = blockFlowchart.moveAbs, stepAbs = blockFlowchart.stepAbs, dx = blockFlowchart.dx, dy = blockFlowchart.dy, stepCond = blockFlowchart.stepCond, withLoop = blockFlowchart.withLoop, shapes = blockFlowchart.shapes, AllocW = blockFlowchart.AllocW, AllocE = blockFlowchart.AllocE, hlineMargin = blockFlowchart.hlineMargin;
    {
        var pos = AllocE.findSpace(blockFlowchart.y + dy - hlineMargin, hlineMargin);
        AllocW.merge(pos, hlineMargin);
        stepAbs(pos + hlineMargin);
    }
    var loopBackMergeY = blockFlowchart.y;
    var condPos = stepCond({
        content: node.content,
        yesDir: 'S', noDir: 'E',
        jumpE: false, jumpW: false,
        stepY: hlineMargin,
    });
    var _a = withLoop('while', function () {
        createFlowchartSub(node, blockFlowchart);
    }), breaks = _a.breaks, continues = _a.continues;
    var loopBackPoints = __spreadArrays(continues);
    var exitPoints = __spreadArrays(breaks);
    if (blockFlowchart.alive) {
        var pos = AllocE.findSpace(blockFlowchart.y, hlineMargin);
        AllocW.merge(pos, hlineMargin);
        stepAbs(pos + hlineMargin);
        loopBackPoints.push(new Point({ x: 0, y: blockFlowchart.y }));
    }
    exitPoints.push(new Point(__assign({}, condPos.E)));
    var loopBackPathX = Math.min(condPos.W.x, shapes.minX) - dx;
    var exitPathX = Math.max(condPos.E.x, shapes.maxX) + dx;
    // loop back path
    loopBackPoints
        .sort(function (p1, p2) { return p1.y > p2.y ? -1 : 1; })
        .forEach(function (p, idx) {
        shapes.add(new Path({
            x: p.x, y: p.y, isArrow: true,
            cmds: idx === 0 ?
                [['h', loopBackPathX - p.x],
                    ['v', loopBackMergeY - p.y],
                    ['h', -loopBackPathX]] :
                [['h', loopBackPathX - p.x]],
        }));
    });
    {
        var pos = AllocE.findSpace(blockFlowchart.y, hlineMargin);
        AllocW.merge(pos, hlineMargin);
        moveAbs(pos + hlineMargin);
    }
    // loop exit path
    exitPoints
        .sort(function (p1, p2) { return p1.y < p2.y ? -1 : 1; })
        .forEach(function (p, idx) {
        shapes.add(new Path({
            x: p.x, y: p.y, isArrow: idx !== 0,
            cmds: idx === 0 ?
                [['h', exitPathX - p.x],
                    ['v', blockFlowchart.y - p.y],
                    ['h', -exitPathX]] :
                [['h', exitPathX - p.x]],
        }));
    });
    flowchart.merge(blockFlowchart);
    // }}}
};
var createDoWhileFlowchart = function (doNode, whileNode, flowchart) {
    // {{{
    //
    //                   |
    //  loop back path   |
    //       +---------->|
    //       |           |
    //       |  block +--+--+
    //       |        |     | break
    //       |        |     +------------------+
    //       |        |     |                  |
    //       |        |     | continue         |
    //       |        |     +---+              |
    //       |        |     |   |              |
    //       |        +--+--+   | skip path    |
    //       |           |      |              |
    //       |           |<-----+              |
    //       |           |                     |
    //       |       _.-' '-._                 |
    //       |      '-._   _.-'--------------->|
    //       |          '+'                    | loop exit path
    //       |           |                     |
    //       +-----------+                     |
    //                                         |
    //                   +---------------------+
    //                   |
    var blockFlowchart = flowchart.branch();
    var moveAbs = blockFlowchart.moveAbs, stepAbs = blockFlowchart.stepAbs, dx = blockFlowchart.dx, dy = blockFlowchart.dy, shapes = blockFlowchart.shapes, withLoop = blockFlowchart.withLoop, AllocW = blockFlowchart.AllocW, AllocE = blockFlowchart.AllocE, hlineMargin = blockFlowchart.hlineMargin;
    {
        var pos = AllocE.findSpace(blockFlowchart.y + dy - hlineMargin, hlineMargin);
        AllocW.merge(pos, hlineMargin);
        stepAbs(pos + hlineMargin);
    }
    var loopBackMergeY = blockFlowchart.y;
    var _a = withLoop('doWhile', function () {
        createFlowchartSub(doNode, blockFlowchart);
    }), breaks = _a.breaks, continues = _a.continues;
    var exitPoints = __spreadArrays(breaks);
    var loopBackPathX;
    var exitPathX;
    var skipPathX = 0;
    if (blockFlowchart.alive || continues.length > 0) {
        if (continues.length > 0) {
            var pos = AllocE.findSpace(blockFlowchart.y, hlineMargin);
            AllocW.merge(pos, hlineMargin);
            if (blockFlowchart.alive) {
                stepAbs(pos + hlineMargin);
            }
            else {
                moveAbs(pos + hlineMargin);
            }
            skipPathX = shapes.maxX + dx;
            continues
                .sort(function (p1, p2) { return p1.y < p2.y ? -1 : 1; })
                .forEach(function (p, idx) {
                shapes.add(new Path({
                    x: p.x, y: p.y,
                    isArrow: idx !== 0 || blockFlowchart.alive,
                    cmds: idx === 0 ?
                        [['h', skipPathX - p.x],
                            ['v', blockFlowchart.y - p.y],
                            ['h', -skipPathX]] :
                        [['h', skipPathX - p.x]],
                }));
            });
        }
        var diamondFlowchart = blockFlowchart.branch();
        var condPos = diamondFlowchart.stepCond({
            content: whileNode.content,
            yesDir: 'S', noDir: 'E',
            jumpW: false, jumpE: false,
        });
        // NOTE: diamondMaxX = (right side of diamond) + ("no" label of diamond)
        var diamondMaxX = diamondFlowchart.shapes.maxX;
        var diamondMinX = diamondFlowchart.shapes.minX;
        blockFlowchart.merge(diamondFlowchart);
        {
            var pos = AllocE.findSpace(blockFlowchart.y, hlineMargin);
            AllocW.merge(pos, hlineMargin);
            stepAbs(pos + hlineMargin);
        }
        loopBackPathX = Math.min(diamondMinX, shapes.minX) - dx;
        // loop back path
        shapes.add(new Path({
            x: 0, y: blockFlowchart.y, isArrow: true,
            cmds: [
                ['h', loopBackPathX],
                ['v', loopBackMergeY - blockFlowchart.y],
                ['h', -loopBackPathX],
            ],
        }));
        if (breaks.length > 0) {
            exitPathX = Math.max(diamondMaxX, shapes.maxX, skipPathX) + dx;
        }
        else {
            // if no "break"s, no need to avoid shapes and skipPath.
            exitPathX = diamondMaxX + dx;
        }
        exitPoints.push(new Point(__assign({}, condPos.E)));
    }
    else {
        {
            var pos = AllocE.findSpace(blockFlowchart.y, hlineMargin);
            AllocW.merge(pos, hlineMargin);
            moveAbs(pos + hlineMargin);
        }
        exitPathX = shapes.maxX + dx;
    }
    // loop exit path
    {
        var pos = AllocE.findSpace(blockFlowchart.y, hlineMargin);
        AllocW.merge(pos, hlineMargin);
        moveAbs(pos + hlineMargin);
    }
    exitPoints
        .sort(function (p1, p2) { return p1.y < p2.y ? -1 : 1; })
        .forEach(function (p, idx) {
        shapes.add(new Path({
            x: p.x, y: p.y, isArrow: idx !== 0,
            cmds: idx === 0 ?
                [['h', exitPathX - p.x],
                    ['v', blockFlowchart.y - p.y],
                    ['h', -exitPathX]] :
                [['h', exitPathX - p.x]],
        }));
    });
    flowchart.merge(blockFlowchart);
    // }}}
};
// const createBlockFlowchart = (node: ASTNode, flowchart: Flowchart, jump: boolean): void => {
// // {{{
//   //            |     
//   //            |
//   //      +-----+-----+ frame border
//   //      | +-------+ |
//   //      | |       | |
//   //      | |       | |
//   //      | +-------+ |
//   //      +-----+-----+
//   //            |      
//   //            |      
//   const {dx, dy, hlineMargin} = flowchart;
//   flowchart.step();
//   const blockFlowchart = flowchart.branch();
//   // find frame border top y-axis space.
//   const frameTopY = blockFlowchart.AllocE.findSpace(
//     blockFlowchart.y,
//     hlineMargin
//   );
//   blockFlowchart.AllocW.merge(frameTopY, hlineMargin);
//   blockFlowchart.stepAbs(frameTopY);
//   createFlowchartSub(node, blockFlowchart);
//   // to avoid blockFlowchart's last node, step blockFlowchart.
//   blockFlowchart.step();
//   // find frame border bottom y-axis space.
//   const frameBottomY = blockFlowchart.AllocE.findSpace(
//     blockFlowchart.y,
//     hlineMargin
//   );
//   blockFlowchart.AllocW.merge(frameTopY, hlineMargin);
//   blockFlowchart.shapes.add(
//     new Rect({
//       x: blockFlowchart.x + blockFlowchart.shapes.minX - dx,
//       y: frameTopY,
//       w: blockFlowchart.shapes.maxX - blockFlowchart.shapes.minX + 2 * dx,
//       h: frameBottomY - frameTopY,
//     })
//   );
//   flowchart.merge(blockFlowchart);
//   if (!blockFlowchart.alive) flowchart.alive = false;
// // }}}
// }
var createTryExceptFlowchart = function (tryNode, exceptNodes, flowchart) {
    // {{{
    //                     |     
    //                     | frame border
    //               +-----+-----+           
    //               | +-------+ | exceptHline
    //               | |       | +------+-------------+
    //   tryShapeGroup |       | |      | error1      | error2
    //               | |       | |      |             |
    //               | |       | |      v             v
    //               | |       | |   +-----+       +-----+ exceptShapeGroups
    //               | +-------+ |   |     |       |     |
    //               +-----+-----+   +--+--+       +--+--+
    //                     |            |             |
    //                     |            |             |
    //                     |<-----------+-------------+
    //                     |  mergeHline
    //                     |
    // NOTE:
    // to find starting point of exceptHline,
    // we can not use createBlockFlowchart directory...
    var dx = flowchart.dx, hlineMargin = flowchart.hlineMargin;
    var tryFlowchart = flowchart.branch();
    var exceptFlowcharts = exceptNodes.map(function () { return flowchart.branch(); });
    var exceptHlineX;
    var exceptHlineY;
    var blockFlowchart = tryFlowchart.branch();
    // find frame border top y-axis space.
    var frameTopY_ = blockFlowchart.AllocE.findSpace(blockFlowchart.y, hlineMargin);
    blockFlowchart.AllocW.merge(frameTopY_, hlineMargin);
    var frameTopY = frameTopY_ + hlineMargin;
    blockFlowchart.stepAbs(frameTopY);
    createFlowchartSub(tryNode, blockFlowchart);
    // NOTE:
    // Since blockFlowchart.AllocE's pointer has
    // already gone to forward,
    // We must use tryFlowchart.AllocE here.
    var exceptHlineY_ = tryFlowchart.AllocE.findSpace(frameTopY, hlineMargin);
    tryFlowchart.AllocW.merge(exceptHlineY_, hlineMargin);
    exceptHlineY = exceptHlineY_ + hlineMargin;
    // find frame border bottom y-axis space.
    var frameBottomY_ = tryFlowchart.AllocE.findSpace(Math.max(blockFlowchart.y, exceptHlineY), hlineMargin);
    tryFlowchart.AllocW.merge(frameBottomY_, hlineMargin);
    var frameBottomY = frameBottomY_ + hlineMargin;
    if (blockFlowchart.alive) {
        // step blockFlowchart.
        blockFlowchart.stepAbs(frameBottomY);
    }
    else {
        // move blockFlowchart.
        blockFlowchart.moveAbs(frameBottomY);
    }
    exceptHlineX = blockFlowchart.x + blockFlowchart.shapes.maxX + dx;
    var rectX = blockFlowchart.x + blockFlowchart.shapes.minX - dx;
    blockFlowchart.shapes.add(new Frame({
        x: rectX,
        y: frameTopY,
        w: exceptHlineX - rectX,
        h: frameBottomY - frameTopY,
    }));
    tryFlowchart.merge(blockFlowchart);
    if (!blockFlowchart.alive)
        tryFlowchart.alive = false;
    // change start y-coordinate of exceptFlowcharts
    exceptFlowcharts.forEach(function (exceptFlowchart) {
        exceptFlowchart.moveAbs(exceptHlineY);
    });
    var prevFlowchart = tryFlowchart;
    exceptNodes.forEach(function (exceptNode, idx) {
        var exceptFlowchart = exceptFlowcharts[idx];
        var startY = exceptFlowchart.y;
        createFlowchartSub(exceptNode, exceptFlowchart);
        var exceptFlowchartX = prevFlowchart.x + prevFlowchart.shapes.maxX + dx - exceptFlowchart.shapes.minX;
        exceptFlowchart.shiftX(exceptFlowchartX);
        exceptFlowchart.shapes.add(exceptFlowchart.textWithAutoSize({
            x: exceptFlowchart.config.label.marginX,
            y: startY + exceptFlowchart.config.label.marginY,
            text: exceptNode.content, isLabel: true,
        }));
        prevFlowchart = exceptFlowchart;
    });
    // draw "exceptHline".
    tryFlowchart.shapes.add(Path.hline({
        x: exceptHlineX, y: exceptHlineY,
        step: exceptFlowcharts.slice(-1)[0].shapes.x - exceptHlineX,
    }));
    // const loopType = flowchart.loop.type;
    // let isTryFlowchartAlive = tryFlowchart.alive;
    var isAnyExceptFlowchartAlive = exceptFlowcharts.some(function (flowchart) { return flowchart.alive; });
    // if any flowchart are alive, find y-axis space for merge position
    if (isAnyExceptFlowchartAlive) {
        var flowchartMaxY = __spreadArrays([tryFlowchart], exceptFlowcharts).map(function (flowchart) { return flowchart.y; })
            .reduce(function (prev, cur) { return Math.max(prev, cur); });
        // find position of mergeHline
        var pos = flowchart.AllocE.findSpace(flowchartMaxY, hlineMargin);
        flowchart.AllocW.merge(pos, hlineMargin);
        var mergeY_1 = pos + hlineMargin;
        // step all alive flowchart to mergeY.
        __spreadArrays([tryFlowchart], exceptFlowcharts).filter(function (flowchart) { return flowchart.alive; })
            .forEach(function (flowchart) {
            flowchart.stepAbs(mergeY_1);
        });
        var lastAliveFlowchart = exceptFlowcharts
            .filter(function (exceptFlowchart) { return exceptFlowchart.alive; })
            .slice(-1)[0];
        // draw "mergeHline".
        tryFlowchart.shapes.add(Path.hline({
            x: lastAliveFlowchart.shapes.x,
            y: mergeY_1,
            step: -lastAliveFlowchart.shapes.x + tryFlowchart.shapes.x,
            isArrow: tryFlowchart.alive,
        }));
    }
    else if (tryFlowchart.alive) {
        // to connect next statement,
        // we should step "tryFlowchart".
        var maxY = __spreadArrays([tryFlowchart], exceptFlowcharts).map(function (flowchart) { return flowchart.y; })
            .reduce(function (prev, cur) { return Math.max(prev, cur); });
        tryFlowchart.stepAbs(maxY);
    }
    flowchart.merge(tryFlowchart);
    exceptFlowcharts.forEach(function (exceptFlowchart) { return flowchart.merge(exceptFlowchart); });
    // if all branch are dead, disable "alive" flag.
    if (__spreadArrays([tryFlowchart], exceptFlowcharts).every(function (flowchart) { return !flowchart.alive; })) {
        flowchart.alive = false;
    }
    // }}}
};
var createSwitchCaseFlowchart = function (switchNode, caseNodes, flowchart) {
    // {{{
    //                 |
    //                 |
    //             _.-' '-._ 
    //            '-._   _.-'
    //                '+'
    //                 | caseHline
    //                 +----------------+--------------+
    //                 | case0Label     | case1Label   | case2Label
    //              +--+--+          +--+--+        +--+--+
    //              |     |          |     |        |     |
    //              +--+--+          +--+--+        +--+--+
    //                 |                |              |
    //                 |                |              |
    //                 |<---------------+--------------+
    //                 | mergeHline
    //
    var dx = flowchart.dx, hlineMargin = flowchart.hlineMargin;
    var blockFlowchart = flowchart.branch();
    var caseFlowcharts = caseNodes.map(function () { return flowchart.branch(); });
    var diamond = blockFlowchart.diamond({
        x: 0,
        y: 0,
        text: switchNode.content,
    });
    // find y-axis space to put vline+diamond+vline
    var _diamondTop = blockFlowchart.AllocE.findSpace(flowchart.y, hlineMargin + diamond.h + hlineMargin);
    blockFlowchart.AllocW.merge(_diamondTop, hlineMargin + diamond.h + hlineMargin);
    var diamondTop = _diamondTop + hlineMargin;
    blockFlowchart.stepAbs(diamondTop, true);
    blockFlowchart.move(diamond.h);
    // draw diamond
    diamond.trans(0, diamondTop);
    blockFlowchart.shapes.add(diamond);
    blockFlowchart.step(hlineMargin);
    var caseHlineY = blockFlowchart.y;
    // change start y-coordinate of exceptFlowcharts
    caseFlowcharts.forEach(function (caseFlowchart) {
        caseFlowchart.moveAbs(caseHlineY);
    });
    var prevFlowchartMaxAbsX = 0;
    caseNodes.forEach(function (caseNode, idx) {
        var caseFlowchart = caseFlowcharts[idx];
        var startY = caseFlowchart.y;
        createFlowchartSub(caseNode, caseFlowchart);
        var caseFlowchartX = idx === 0 ? 0 : prevFlowchartMaxAbsX + dx - caseFlowchart.shapes.minX;
        caseFlowchart.shiftX(caseFlowchartX);
        caseFlowchart.shapes.add(caseFlowchart.textWithAutoSize({
            x: caseFlowchart.config.label.marginX,
            y: startY + caseFlowchart.config.label.marginY,
            text: caseNode.content, isLabel: true,
        }));
        prevFlowchartMaxAbsX = caseFlowchart.x + caseFlowchart.shapes.maxX;
    });
    // draw "caseHline"
    blockFlowchart.shapes.add(Path.hline({
        x: 0,
        y: caseHlineY,
        step: caseFlowcharts.slice(-1)[0].shapes.x,
    }));
    var aliveCaseFlowchartNum = caseFlowcharts
        .map(function (caseFlowchart) { return (caseFlowchart.alive ? 1 : 0); })
        .reduce(function (prev, cur) { return (prev + cur); });
    var flowchartMaxY = caseFlowcharts
        .map(function (flowchart) { return flowchart.y; })
        .reduce(function (prev, cur) { return Math.max(prev, cur); });
    // if any flowchart are alive, find y-axis space for merge position
    if (aliveCaseFlowchartNum > 0
        &&
            // if first case is alive and alone, no need to draw mergeHline
            !(caseFlowcharts[0].alive
                && aliveCaseFlowchartNum === 1)) {
        // find position of mergeHline
        var pos = flowchart.AllocE.findSpace(flowchartMaxY, hlineMargin);
        flowchart.AllocW.merge(pos, hlineMargin);
        var mergeY_2 = pos + hlineMargin;
        // step all alive flowchart to mergeY.
        caseFlowcharts
            .filter(function (caseFlowchart) { return caseFlowchart.alive; })
            .forEach(function (caseFlowchart) {
            caseFlowchart.stepAbs(mergeY_2);
        });
        var lastAliveFlowchart = caseFlowcharts
            .filter(function (caseFlowchart) { return caseFlowchart.alive; })
            .slice(-1)[0];
        // draw "mergeHline".
        blockFlowchart.shapes.add(Path.hline({
            x: lastAliveFlowchart.shapes.x,
            y: mergeY_2,
            step: -lastAliveFlowchart.shapes.x + blockFlowchart.shapes.x,
            isArrow: caseFlowcharts[0].alive,
        }));
    }
    // NOTE: because of mergeHline,
    // some flowchart might grow from previous flowchartMaxY
    var flowchartMaxY2 = caseFlowcharts
        .map(function (flowchart) { return flowchart.y; })
        .reduce(function (prev, cur) { return Math.max(prev, cur); });
    // step all flowchart to mergeY.
    caseFlowcharts
        .forEach(function (caseFlowchart) {
        if (caseFlowchart.alive) {
            caseFlowchart.stepAbs(flowchartMaxY2);
        }
        else {
            caseFlowchart.moveAbs(flowchartMaxY2);
        }
    });
    flowchart.merge(blockFlowchart);
    caseFlowcharts.forEach(function (caseFlowchart) {
        flowchart.merge(caseFlowchart);
    });
    // if all branch are dead, disable "alive" flag.
    if (aliveCaseFlowchartNum === 0) {
        flowchart.alive = false;
    }
    // }}}
};
export { createFlowchart, Flowchart, };
//# sourceMappingURL=flowchart.js.map