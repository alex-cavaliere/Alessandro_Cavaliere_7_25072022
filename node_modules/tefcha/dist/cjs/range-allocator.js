"use strict";
// We have to manage y-axis allocation,
// because when laying out horizontal lines,
// we want to avoid other nodes or horizontal lines.
Object.defineProperty(exports, "__esModule", { value: true });
exports.RangeAllocator = exports.createRangeList = void 0;
var isRangeListTail = function (obj) {
    return (typeof (obj === null || obj === void 0 ? void 0 : obj.start) === 'number'
        && typeof (obj === null || obj === void 0 ? void 0 : obj.end) === 'number'
        && (obj === null || obj === void 0 ? void 0 : obj.next) === null);
};
var createRangeList = function () {
    var ranges = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        ranges[_i] = arguments[_i];
    }
    var tail = {
        start: Infinity,
        end: Infinity,
        next: null,
    };
    var cur = tail;
    ranges.slice().reverse().forEach(function (_a) {
        var start = _a[0], end = _a[1];
        var range = {
            start: start, end: end,
            next: cur,
        };
        cur = range;
    });
    var head = {
        start: -Infinity,
        end: -Infinity,
        next: cur,
    };
    return head;
};
exports.createRangeList = createRangeList;
var RangeAllocator = /** @class */ (function () {
    function RangeAllocator(rangeList) {
        var _this = this;
        this.clone = function () {
            return new RangeAllocator(_this.head);
        };
        this.cloneDeep = function () {
            // clone range list too.
            return new RangeAllocator(createRangeList.apply(void 0, _this.ranges().map(function (_a) {
                var start = _a.start, end = _a.end;
                return [start, end];
            })));
        };
        this.findSpace = function (start, size) {
            //  Find enough space to put the range of size "size".
            //
            //          size
            //        <------>                      
            //        +------+              .       
            //        |      | NG           .       
            //        +------+       OK     .
            //        .    .      +------+  .              
            //        .    .      |      |  .         
            //        .    .      +------+  .         
            //        .    .      .         .
            //  +-----+    +------+         +---+   
            //  |     |    |      |         |   |   ... range list
            //  +-----+    +------+         +---+   
            // 
            var cur = _this.head;
            while (!isRangeListTail(cur.next)
                && cur.next.start < start) {
                cur = cur.next;
            }
            var prevEnd = Math.max(start, cur.end);
            while (!isRangeListTail(cur.next)
                && cur.next.start - prevEnd < size) {
                cur = cur.next;
                prevEnd = cur.end;
            }
            return prevEnd;
        };
        this.merge = function (start, size) {
            //  Allocate range between "start" and "end"
            //  and merge all ranges in this range
            //
            //    Before
            //
            //     start                  end
            //     v                      v 
            //     +------         -------+
            //     | merge ...            |
            //     +------         -------+
            //  +-----+   +---+     +---+ .  +---+ 
            //  |     |   |   | ... |   | .  |   | ... range list
            //  +-----+   +---+     +---+ .  +---+ 
            //  .                         .
            //  .                         .
            //  . After                   .
            //  .                         .
            //  +-------------------------+  +---+            
            //  |  merged                 |  |   | ... range list
            //  +-------------------------+  +---+            
            //
            var end = start + size;
            var cur = _this.head;
            var range;
            while (!isRangeListTail(cur.next)
                && cur.next.start <= start) {
                cur = cur.next;
            }
            if (start <= cur.end) {
                //    start
                //    v
                //    +------            
                //    | merge ...
                //    +------            
                // +-----+     +------+
                // | cur |     | next |
                // +-----+     +------+
                //
                // Corner Case:
                //
                //  start
                //  v
                //  +------            
                //  | merge ...
                //  +------            
                //  +-----+     +------+
                //  | cur |     | next |
                //  +-----+     +------+
                range = cur;
            }
            else {
                //          start
                //          v
                //          +------            
                //          | merge ...
                //          +------            
                // +-----+     +------+
                // | cur |     | next |
                // +-----+     +------+
                range = {
                    start: start,
                    end: start,
                    next: cur.next,
                };
                cur.next = range;
                cur = range;
            }
            while (!isRangeListTail(cur.next)
                && cur.next.start <= end) {
                cur = cur.next;
            }
            if (end <= cur.end) {
                //           end
                //           v
                //    -------+                  
                // ... merge |              
                //    -------+                  
                //        +-----+     +------+
                //        | cur |     | next |
                //        +-----+     +------+
                //
                // Corner Case:
                //
                //           end
                //           v
                //    -------+                  
                // ... merge |              
                //    -------+                  
                //           +-----+     +------+
                //           | cur |     | next |
                //           +-----+     +------+
                range.end = cur.end;
                range.next = cur.next;
            }
            else {
                //            end
                //            v
                //     -------+                  
                //  ... merge |              
                //     -------+                  
                //   +-----+     +------+
                //   | cur |     | next |
                //   +-----+     +------+
                range.end = end;
                range.next = cur.next;
            }
        };
        this.ranges = function () {
            // NOTE: this method does not change ref.
            var ret = [];
            var cur = _this.head;
            if (cur.start === -Infinity) {
                cur = cur.next;
            }
            while (!isRangeListTail(cur)) {
                ret.push({ start: cur.start, end: cur.end });
                cur = cur.next;
            }
            return ret;
        };
        this.mergeAllocator = function (allocator) {
            allocator.ranges().forEach(function (_a) {
                var start = _a.start, end = _a.end;
                _this.merge(start, end - start);
            });
        };
        this.head = rangeList;
    }
    return RangeAllocator;
}());
exports.RangeAllocator = RangeAllocator;
//# sourceMappingURL=range-allocator.js.map